<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/nlp-compromise/nlp_compromise#readme"

    >nlp_compromise (v6.5.3)</a>
</h1>
<h4>natural language processing in the browser</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.nlp_compromise">module nlp_compromise</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.adjective">
            function <span class="apidocSignatureSpan">nlp_compromise.</span>adjective
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.adverb">
            function <span class="apidocSignatureSpan">nlp_compromise.</span>adverb
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.date">
            function <span class="apidocSignatureSpan">nlp_compromise.</span>date
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.lexicon">
            function <span class="apidocSignatureSpan">nlp_compromise.</span>lexicon
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.noun">
            function <span class="apidocSignatureSpan">nlp_compromise.</span>noun
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.organization">
            function <span class="apidocSignatureSpan">nlp_compromise.</span>organization
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.person">
            function <span class="apidocSignatureSpan">nlp_compromise.</span>person
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.place">
            function <span class="apidocSignatureSpan">nlp_compromise.</span>place
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.plugin">
            function <span class="apidocSignatureSpan">nlp_compromise.</span>plugin
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.question">
            function <span class="apidocSignatureSpan">nlp_compromise.</span>question
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.sentence">
            function <span class="apidocSignatureSpan">nlp_compromise.</span>sentence
            <span class="apidocSignatureSpan">(s, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.statement">
            function <span class="apidocSignatureSpan">nlp_compromise.</span>statement
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.term">
            function <span class="apidocSignatureSpan">nlp_compromise.</span>term
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.text">
            function <span class="apidocSignatureSpan">nlp_compromise.</span>text
            <span class="apidocSignatureSpan">(s, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.value">
            function <span class="apidocSignatureSpan">nlp_compromise.</span>value
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.verb">
            function <span class="apidocSignatureSpan">nlp_compromise.</span>verb
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nlp_compromise.</span>fns</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nlp_compromise.</span>index</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nlp_compromise.</span>match</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nlp_compromise.</span>parts_of_speech</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nlp_compromise.fns">module nlp_compromise.fns</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.fns.endsWith">
            function <span class="apidocSignatureSpan">nlp_compromise.fns.</span>endsWith
            <span class="apidocSignatureSpan">(str, suffix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.fns.expand_prefixes">
            function <span class="apidocSignatureSpan">nlp_compromise.fns.</span>expand_prefixes
            <span class="apidocSignatureSpan">(list, obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.fns.expand_suffixes">
            function <span class="apidocSignatureSpan">nlp_compromise.fns.</span>expand_suffixes
            <span class="apidocSignatureSpan">(list, obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.fns.extend">
            function <span class="apidocSignatureSpan">nlp_compromise.fns.</span>extend
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.fns.flatten">
            function <span class="apidocSignatureSpan">nlp_compromise.fns.</span>flatten
            <span class="apidocSignatureSpan">(arr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.fns.isFunction">
            function <span class="apidocSignatureSpan">nlp_compromise.fns.</span>isFunction
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.fns.pluck">
            function <span class="apidocSignatureSpan">nlp_compromise.fns.</span>pluck
            <span class="apidocSignatureSpan">(arr, str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.fns.reverseObj">
            function <span class="apidocSignatureSpan">nlp_compromise.fns.</span>reverseObj
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.fns.startsWith">
            function <span class="apidocSignatureSpan">nlp_compromise.fns.</span>startsWith
            <span class="apidocSignatureSpan">(str, prefix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.fns.titlecase">
            function <span class="apidocSignatureSpan">nlp_compromise.fns.</span>titlecase
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.fns.toObj">
            function <span class="apidocSignatureSpan">nlp_compromise.fns.</span>toObj
            <span class="apidocSignatureSpan">(arr)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nlp_compromise.index">module nlp_compromise.index</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.index.adjective">
            function <span class="apidocSignatureSpan">nlp_compromise.index.</span>adjective
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.index.adverb">
            function <span class="apidocSignatureSpan">nlp_compromise.index.</span>adverb
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.index.date">
            function <span class="apidocSignatureSpan">nlp_compromise.index.</span>date
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.index.lexicon">
            function <span class="apidocSignatureSpan">nlp_compromise.index.</span>lexicon
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.index.noun">
            function <span class="apidocSignatureSpan">nlp_compromise.index.</span>noun
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.index.organization">
            function <span class="apidocSignatureSpan">nlp_compromise.index.</span>organization
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.index.person">
            function <span class="apidocSignatureSpan">nlp_compromise.index.</span>person
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.index.place">
            function <span class="apidocSignatureSpan">nlp_compromise.index.</span>place
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.index.plugin">
            function <span class="apidocSignatureSpan">nlp_compromise.index.</span>plugin
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.index.question">
            function <span class="apidocSignatureSpan">nlp_compromise.index.</span>question
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.index.sentence">
            function <span class="apidocSignatureSpan">nlp_compromise.index.</span>sentence
            <span class="apidocSignatureSpan">(s, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.index.statement">
            function <span class="apidocSignatureSpan">nlp_compromise.index.</span>statement
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.index.term">
            function <span class="apidocSignatureSpan">nlp_compromise.index.</span>term
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.index.text">
            function <span class="apidocSignatureSpan">nlp_compromise.index.</span>text
            <span class="apidocSignatureSpan">(s, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.index.value">
            function <span class="apidocSignatureSpan">nlp_compromise.index.</span>value
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.index.verb">
            function <span class="apidocSignatureSpan">nlp_compromise.index.</span>verb
            <span class="apidocSignatureSpan">(s)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nlp_compromise.match">module nlp_compromise.match</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.match.findAll">
            function <span class="apidocSignatureSpan">nlp_compromise.match.</span>findAll
            <span class="apidocSignatureSpan">(terms, regs, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.match.replaceAll">
            function <span class="apidocSignatureSpan">nlp_compromise.match.</span>replaceAll
            <span class="apidocSignatureSpan">(terms, regs, replacement, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nlp_compromise.parts_of_speech">module nlp_compromise.parts_of_speech</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.parts_of_speech.Adjective">
            function <span class="apidocSignatureSpan">nlp_compromise.parts_of_speech.</span>Adjective
            <span class="apidocSignatureSpan">(str, tag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.parts_of_speech.Adverb">
            function <span class="apidocSignatureSpan">nlp_compromise.parts_of_speech.</span>Adverb
            <span class="apidocSignatureSpan">(str, tag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.parts_of_speech.Date">
            function <span class="apidocSignatureSpan">nlp_compromise.parts_of_speech.</span>Date
            <span class="apidocSignatureSpan">(str, tag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.parts_of_speech.Noun">
            function <span class="apidocSignatureSpan">nlp_compromise.parts_of_speech.</span>Noun
            <span class="apidocSignatureSpan">(str, tag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.parts_of_speech.Organization">
            function <span class="apidocSignatureSpan">nlp_compromise.parts_of_speech.</span>Organization
            <span class="apidocSignatureSpan">(str, tag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.parts_of_speech.Person">
            function <span class="apidocSignatureSpan">nlp_compromise.parts_of_speech.</span>Person
            <span class="apidocSignatureSpan">(str, tag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.parts_of_speech.Place">
            function <span class="apidocSignatureSpan">nlp_compromise.parts_of_speech.</span>Place
            <span class="apidocSignatureSpan">(str, tag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.parts_of_speech.Term">
            function <span class="apidocSignatureSpan">nlp_compromise.parts_of_speech.</span>Term
            <span class="apidocSignatureSpan">(str, tag, whitespace)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.parts_of_speech.Value">
            function <span class="apidocSignatureSpan">nlp_compromise.parts_of_speech.</span>Value
            <span class="apidocSignatureSpan">(str, tag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nlp_compromise.parts_of_speech.Verb">
            function <span class="apidocSignatureSpan">nlp_compromise.parts_of_speech.</span>Verb
            <span class="apidocSignatureSpan">(str, tag)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nlp_compromise.parts_of_speech.</span>classMapping</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">nlp_compromise.parts_of_speech.</span>tag_mapping</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nlp_compromise" id="apidoc.module.nlp_compromise">module nlp_compromise</a></h1>


    <h2>
        <a href="#apidoc.element.nlp_compromise.adjective" id="apidoc.element.nlp_compromise.adjective">
        function <span class="apidocSignatureSpan">nlp_compromise.</span>adjective
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">adjective = function (s) {
  return new models.Adjective(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.adverb" id="apidoc.element.nlp_compromise.adverb">
        function <span class="apidocSignatureSpan">nlp_compromise.</span>adverb
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">adverb = function (s) {
  return new models.Adverb(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.date" id="apidoc.element.nlp_compromise.date">
        function <span class="apidocSignatureSpan">nlp_compromise.</span>date
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">date = function (s) {
  return new models.Date(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}(Noun);

_Date.fn = _Date.prototype;

module.exports = _Date;

// let d = new _Date(&#x27;June 4th 1993&#x27;);
// console.log(d.<span class="apidocCodeKeywordSpan">date</span>());

},{&#x22;../noun.js&#x22;:80,&#x22;./parse_date.js&#x22;:77}],75:[function(_dereq_,module,exports){
&#x27;use strict&#x27;;

var months = _dereq_(&#x27;../../../data/dates&#x27;).months.concat([&#x27;march&#x27;, &#x27;may&#x27;]); //(march and may are
ambiguous grammatically)
var month = &#x27;(&#x27; + months.join(&#x27;|&#x27;) + &#x27;)&#x27;;
var day = &#x27;([0-9]{1,2})&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.lexicon" id="apidoc.element.nlp_compromise.lexicon">
        function <span class="apidocSignatureSpan">nlp_compromise.</span>lexicon
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lexicon = function (obj) {
  obj = obj || {};
  var lex = _dereq_(&#x27;./lexicon.js&#x27;);

  Object.keys(obj).forEach(function (k) {
    lex[k] = obj[k];
  });

  return lex;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Uses semver, with occasional releases to npm and bower.

here, &#x27;Major&#x27; is considered an api change, while &#x27;Minor&#x27; is considered a performance change.

### v.6  &#x26;nbsp;
* 6.5.0 - builds now using browserify + derequire()
* 6.4.0 - re-written term-lumper logic
* 6.3.0 - new nlp.<span class="apidocCodeKeywordSpan">lexicon</span>({word:&#x27;POS&#x27;}) flow
* 6.0.0 - be consistent with `text.normal()`, `term.all_forms()`, `text.word_count()`. `text.normal()` includes sentence-terminators
, like periods etc.

### v.5  &#x26;nbsp;
* 5.2.0 - airport codes support, helper methods for specific POS
* 5.1.0 - newlines split sentences
* 5.0.0 - Text methods now return this, instead of array of sentences
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.noun" id="apidoc.element.nlp_compromise.noun">
        function <span class="apidocSignatureSpan">nlp_compromise.</span>noun
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">noun = function (s) {
  return new models.Noun(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x3e; `npm install nlp_compromise`

&#x3e; `&#x3c;script src=&#x22;https://unpkg.com/nlp_compromise@latest/builds/nlp_compromise.min.js&#x22;&#x3e;&#x3c;/script&#x3e
;`

```javascript
let nlp = require(&#x27;nlp_compromise&#x27;); // or nlp = window.nlp_compromise

nlp.<span class="apidocCodeKeywordSpan">noun</span>(&#x27;dinosaur&#x27;).pluralize();
// &#x27;dinosaurs&#x27;

nlp.verb(&#x27;speak&#x27;).conjugate();
// { past: &#x27;spoke&#x27;,
//   infinitive: &#x27;speak&#x27;,
//   gerund: &#x27;speaking&#x27;,
//   actor: &#x27;speaker&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.organization" id="apidoc.element.nlp_compromise.organization">
        function <span class="apidocSignatureSpan">nlp_compromise.</span>organization
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">organization = function (s) {
  return new models.Organization(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.person" id="apidoc.element.nlp_compromise.person">
        function <span class="apidocSignatureSpan">nlp_compromise.</span>person
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">person = function (s) {
  return new models.Person(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

nlp.text(&#x27;Tony Hawk did a kickflip&#x27;).people();
// [ Person { text: &#x27;Tony Hawk&#x27; ..} ]

nlp.noun(&#x27;vacuum&#x27;).article();
// &#x27;a&#x27;

nlp.<span class="apidocCodeKeywordSpan">person</span>(&#x27;Tony Hawk&#x27;).pronoun();
// &#x27;he&#x27;

nlp.value(&#x27;five hundred and sixty&#x27;).number;
// 560

nlp.text(require(&#x27;nlp-corpus&#x27;).text.friends()).topics()//11 seasons of friends
// [ { count: 2523, text: &#x27;ross&#x27; },
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.place" id="apidoc.element.nlp_compromise.place">
        function <span class="apidocSignatureSpan">nlp_compromise.</span>place
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">place = function (s) {
  return new models.Place(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### v.2
* v2.0.0 - Nov 2015 &#x26;nbsp;  **(Breaking)**
* es6 classes, babel building
* better test coverage
* ngram uses term tokenization, so that &#x27;Tony Hawk&#x27; us one term, and not two
* more organized pos rules
* Pos tagging is done implicitly now once nlp.Text is run
* Entity spotting is split into .people(), .<span class="apidocCodeKeywordSpan">place</span>(), .organisations()
* unicode normalisation is killed
* opaque two-letter tags are gone
* plugin support
* passive tense detection
* lexicon can be augmented third-party
* date parsing results are different
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.plugin" id="apidoc.element.nlp_compromise.plugin">
        function <span class="apidocSignatureSpan">nlp_compromise.</span>plugin
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">plugin = function (obj) {
  obj = obj || {};
  // if obj is a function, pass it an instance of this nlp library
  if (fns.isFunction(obj)) {
    // run it in this current context
    obj = obj.call(this, this);
  }
  //apply each plugin to the correct prototypes
  Object.keys(obj).forEach(function (k) {
    Object.keys(obj[k]).forEach(function (method) {
      models[k].prototype[method] = obj[k][method];
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//   { count: 1411, text: &#x27;rachel&#x27; },
//   ....
```
#Plugin/Mixins
we&#x27;ve also got a modest, though ambitious [plugin ecosystem](https://github.com/nlp-compromise/nlp_compromise/wiki/Plugins):
```javascript
//US-UK localization
nlp.<span class="apidocCodeKeywordSpan">plugin</span>(require(&#x27;nlp-locale&#x27;))
nlp.term(&#x27;favourite&#x27;).toAmerican()
// &#x27;favorite&#x27;

//syllable hyphenization
nlp.plugin(require(&#x27;nlp-syllables&#x27;));
var t2 = nlp.term(&#x27;houston texas&#x27;);
t2.syllables()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.question" id="apidoc.element.nlp_compromise.question">
        function <span class="apidocSignatureSpan">nlp_compromise.</span>question
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">question = function (s) {
  return new models.Question(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.sentence" id="apidoc.element.nlp_compromise.sentence">
        function <span class="apidocSignatureSpan">nlp_compromise.</span>sentence
        <span class="apidocSignatureSpan">(s, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sentence = function (s, options) {
  return new models.Sentence(s, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

[![CodacyBadge](https://api.codacy.com/project/badge/grade/82cc8ebd98b64ed199d7be6021488062)](https://www.codacy.com/app/spencerkelly86
/nlp_compromise)
[![npm version](https://badge.fury.io/js/nlp_compromise.svg)](https://www.npmjs.com/package/nlp_compromise)
[![downloads](https://img.shields.io/npm/dm/nlp_compromise.svg)](https://www.npmjs.com/package/nlp_compromise)

**nlp_compromise** does NLP in the browser.
```javascript
nlp.<span class="apidocCodeKeywordSpan">sentence</span>(&#x27;She sells seashells&#x27;).to_past().text()
// &#x27;She sold seashells&#x27;
```
### Yup,
* **&#x3c;150k** js file
* **86%** on the [Penn treebank](http://www.cis.upenn.edu/~treebank/)
* keypress speed, constant-time.
* caniuse, uhuh. **IE9+**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.statement" id="apidoc.element.nlp_compromise.statement">
        function <span class="apidocSignatureSpan">nlp_compromise.</span>statement
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">statement = function (s) {
  return new models.Statement(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//   present: &#x27;speaks&#x27;,
//   future: &#x27;will speak&#x27;,
//   perfect: &#x27;have spoken&#x27;,
//   pluperfect: &#x27;had spoken&#x27;,
//   future_perfect: &#x27;will have spoken&#x27;
// }

nlp.<span class="apidocCodeKeywordSpan">statement</span>(&#x27;She sells seashells&#x27;).negate().text()
// &#x27;She doesn&#x27;t sell seashells&#x27;

nlp.sentence(&#x27;I fed the dog&#x27;).replace(&#x27;the [Noun]&#x27;, &#x27;the cat&#x27;).text()
// &#x27;I fed the cat&#x27;

nlp.text(&#x27;Tony Hawk did a kickflip&#x27;).people();
// [ Person { text: &#x27;Tony Hawk&#x27; ..} ]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.term" id="apidoc.element.nlp_compromise.term">
        function <span class="apidocSignatureSpan">nlp_compromise.</span>term
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">term = function (s) {
  return new models.Term(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//   ....
```
#Plugin/Mixins
we&#x27;ve also got a modest, though ambitious [plugin ecosystem](https://github.com/nlp-compromise/nlp_compromise/wiki/Plugins):
```javascript
//US-UK localization
nlp.plugin(require(&#x27;nlp-locale&#x27;))
nlp.<span class="apidocCodeKeywordSpan">term</span>(&#x27;favourite&#x27;).toAmerican()
// &#x27;favorite&#x27;

//syllable hyphenization
nlp.plugin(require(&#x27;nlp-syllables&#x27;));
var t2 = nlp.term(&#x27;houston texas&#x27;);
t2.syllables()
//[ [ &#x27;hous&#x27;, &#x27;ton&#x27; ], [ &#x27;tex&#x27;, &#x27;as&#x27; ] ]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.text" id="apidoc.element.nlp_compromise.text">
        function <span class="apidocSignatureSpan">nlp_compromise.</span>text
        <span class="apidocSignatureSpan">(s, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">text = function (s, options) {
  return new models.Text(s, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### v.4  &#x26;nbsp;
* 4.12.0 - more-sensible responses for invalid, non-string inputs
* 4.11.0 - 14 PRs, with fixes for currencies, pluralization, conjugation
* 4.10.0 - Value.to_text() new method, fix &#x22;Posessive&#x22; POS typo
* 4.9.0 - return of the text.spot() method (Re:#107)
* 4.8.0 - more aggressive lumping of dates, like &#x27;last week of february&#x27;
* 4.7.0 - whitespace reproduction in .<span class="apidocCodeKeywordSpan">text</span>() methods
* 4.6.0 - move negate from sentence to verb &#x26; statement
* 4.2.0 - rename &#x27;implicit&#x27; to &#x27;expansion&#x27; for smarter contractions
* 4.1.3 - added readable-compression to adj, verbs (121kb -&#x3e; 117kb)
* 4.1.0 - hyphenated words are normalized into spaces
* 4.0.0 - grammar-aware match &#x26; replace functions

### v.3  &#x26;nbsp;  **(Breaking)**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.value" id="apidoc.element.nlp_compromise.value">
        function <span class="apidocSignatureSpan">nlp_compromise.</span>value
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">value = function (s) {
  return new models.Value(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

nlp.noun(&#x27;vacuum&#x27;).article();
// &#x27;a&#x27;

nlp.person(&#x27;Tony Hawk&#x27;).pronoun();
// &#x27;he&#x27;

nlp.<span class="apidocCodeKeywordSpan">value</span>(&#x27;five hundred and sixty&#x27;).number;
// 560

nlp.text(require(&#x27;nlp-corpus&#x27;).text.friends()).topics()//11 seasons of friends
// [ { count: 2523, text: &#x27;ross&#x27; },
//   { count: 1922, text: &#x27;joey&#x27; },
//   { count: 1876, text: &#x27;god&#x27; },
//   { count: 1411, text: &#x27;rachel&#x27; },
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.verb" id="apidoc.element.nlp_compromise.verb">
        function <span class="apidocSignatureSpan">nlp_compromise.</span>verb
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verb = function (s) {
  return new models.Verb(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
let nlp = require(&#x27;nlp_compromise&#x27;); // or nlp = window.nlp_compromise

nlp.noun(&#x27;dinosaur&#x27;).pluralize();
// &#x27;dinosaurs&#x27;

nlp.<span class="apidocCodeKeywordSpan">verb</span>(&#x27;speak&#x27;).conjugate();
// { past: &#x27;spoke&#x27;,
//   infinitive: &#x27;speak&#x27;,
//   gerund: &#x27;speaking&#x27;,
//   actor: &#x27;speaker&#x27;,
//   present: &#x27;speaks&#x27;,
//   future: &#x27;will speak&#x27;,
//   perfect: &#x27;have spoken&#x27;,
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nlp_compromise.fns" id="apidoc.module.nlp_compromise.fns">module nlp_compromise.fns</a></h1>


    <h2>
        <a href="#apidoc.element.nlp_compromise.fns.endsWith" id="apidoc.element.nlp_compromise.fns.endsWith">
        function <span class="apidocSignatureSpan">nlp_compromise.fns.</span>endsWith
        <span class="apidocSignatureSpan">(str, suffix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">endsWith = function (str, suffix) {
  //if suffix is regex
  if (suffix &#x26;&#x26; suffix instanceof RegExp) {
    if (str.match(suffix)) {
      return true;
    }
  }
  //if suffix is a string
  if (str &#x26;&#x26; suffix &#x26;&#x26; str.indexOf(suffix, str.length - suffix.length) !== -1) {
    return true;
  }
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

//leading ^ flag
if (fns.startsWith(term, &#x27;^&#x27;)) {
  term = term.substr(1, term.length);
  signals.leading = true;
}
//trailing $ flag means ending
if (fns.<span class="apidocCodeKeywordSpan">endsWith</span>(term, &#x27;$&#x27;)) {
  term = term.replace(/\$$/, &#x27;&#x27;);
  signals.trailing = true;
}
//optional flag
if (fns.endsWith(term, &#x27;?&#x27;)) {
  term = term.replace(/\?$/, &#x27;&#x27;);
  signals.optional = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.fns.expand_prefixes" id="apidoc.element.nlp_compromise.fns.expand_prefixes">
        function <span class="apidocSignatureSpan">nlp_compromise.fns.</span>expand_prefixes
        <span class="apidocSignatureSpan">(list, obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expand_prefixes = function (list, obj) {
  let keys = Object.keys(obj);
  let l = keys.length;
  for (let i = 0; i &#x3c; l; i++) {
    const arr = obj[keys[i]].split(&#x27;,&#x27;);
    for (let i2 = 0; i2 &#x3c; arr.length; i2++) {
      list.push(keys[i] + arr[i2]);
    }
  }
  return list;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var prefix_compressed = {
  mar: &#x27;go,isol,itza,sha&#x27;,
  tam: &#x27;i,ika,my&#x27;,
  be: &#x27;atriz,cky,tty,ttye&#x27;,
  pe: &#x27;arl,ggy,nny&#x27;,
  pa: &#x27;ige,m,tty&#x27;
};
arr = fns.<span class="apidocCodeKeywordSpan">expand_prefixes</span>(arr, prefix_compressed);

module.exports = arr;

},{&#x22;../../fns&#x22;:23}],15:[function(_dereq_,module,exports){
&#x27;use strict&#x27;;

var fns = _dereq_(&#x27;../../fns&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.fns.expand_suffixes" id="apidoc.element.nlp_compromise.fns.expand_suffixes">
        function <span class="apidocSignatureSpan">nlp_compromise.fns.</span>expand_suffixes
        <span class="apidocSignatureSpan">(list, obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expand_suffixes = function (list, obj) {
  let keys = Object.keys(obj);
  let l = keys.length;
  for (let i = 0; i &#x3c; l; i++) {
    const arr = obj[keys[i]].split(&#x27;,&#x27;);
    for (let i2 = 0; i2 &#x3c; arr.length; i2++) {
      list.push(arr[i2] + keys[i]);
    }
  }
  return list;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  ul: &#x27;fo,gainf,helpf,painf&#x27;
};

var arr = [&#x27;ablaze&#x27;, &#x27;above&#x27;, &#x27;adult&#x27;, &#x27;ahead&#x27;, &#x27;aloof&#x27;, &#x27;arab&#x27;, &#x27
;asleep&#x27;, &#x27;average&#x27;, &#x27;awake&#x27;, &#x27;backwards&#x27;, &#x27;bad&#x27;, &#x27;blank&#x27;, &#x27;bogus&#x27
;, &#x27;bottom&#x27;, &#x27;brisk&#x27;, &#x27;cagey&#x27;, &#x27;chief&#x27;, &#x27;civil&#x27;, &#x27;common&#x27;, &#x27;complex
&#x27;, &#x27;cozy&#x27;, &#x27;crisp&#x27;, &#x27;deaf&#x27;, &#x27;devout&#x27;, &#x27;difficult&#x27;, &#x27;downtown&#x27;, &#
x27;due&#x27;, &#x27;dumb&#x27;, &#x27;eerie&#x27;, &#x27;evil&#x27;, &#x27;excess&#x27;, &#x27;extra&#x27;, &#x27;fake&#x27;, &#
x27;far&#x27;, &#x27;faux&#x27;, &#x27;fierce &#x27;, &#x27;fit&#x27;, &#x27;foreign&#x27;, &#x27;fun&#x27;, &#x27;good&#x27;, &#
x27;goofy&#x27;, &#x27;gratis&#x27;, &#x27;grey&#x27;, &#x27;groovy&#x27;, &#x27;gross&#x27;, &#x27;half&#x27;, &#x27;huge&#x27;, &#
x27;humdrum&#x27;, &#x27;inside&#x27;, &#x27;kaput&#x27;,
//  &#x27;lax&#x27;, -&#x3e; airports
&#x27;left&#x27;, &#x27;less&#x27;, &#x27;level&#x27;, &#x27;lewd&#x27;, &#x27;magenta&#x27;, &#x27;makeshift&#x27;, &#x27;mammoth
&#x27;, &#x27;medium&#x27;, &#x27;moot&#x27;, &#x27;naive&#x27;, &#x27;nearby&#x27;, &#x27;next&#x27;, &#x27;nonstop&#x27;, &#x27
;north&#x27;, &#x27;offbeat&#x27;, &#x27;ok&#x27;, &#x27;outside&#x27;, &#x27;overwrought&#x27;, &#x27;premium&#x27;, &#x27;pricey
&#x27;, &#x27;pro&#x27;, &#x27;quaint&#x27;, &#x27;random&#x27;, &#x27;rear&#x27;, &#x27;rebel&#x27;, &#x27;ritzy&#x27;, &#x27;rough
&#x27;, &#x27;savvy&#x27;, &#x27;sexy&#x27;, &#x27;shut&#x27;, &#x27;shy&#x27;, &#x27;sleek&#x27;, &#x27;smug&#x27;, &#x27;solemn
&#x27;, &#x27;south&#x27;, &#x27;stark&#x27;, &#x27;superb&#x27;, &#x27;taboo&#x27;, &#x27;teenage&#x27;, &#x27;top&#x27;, &#x27
;tranquil&#x27;, &#x27;ultra&#x27;, &#x27;understood&#x27;, &#x27;unfair&#x27;, &#x27;unknown&#x27;, &#x27;upbeat&#x27;, &#x27;upstairs
&#x27;, &#x27;vanilla&#x27;, &#x27;various&#x27;, &#x27;widespread&#x27;, &#x27;woozy&#x27;, &#x27;wrong&#x27;, &#x27;final&#x27
;, &#x27;true&#x27;, &#x27;modern&#x27;, &#x27;notable&#x27;];

module.exports = fns.<span class="apidocCodeKeywordSpan">expand_suffixes</span>(arr, compressed);

},{&#x22;../fns&#x22;:23}],3:[function(_dereq_,module,exports){
&#x27;use strict&#x27;;

//these are adjectives that can become comparative + superlative with out &#x22;most/more&#x22;
//its a whitelist for conjugation
//this data is shared between comparative/superlative methods
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.fns.extend" id="apidoc.element.nlp_compromise.fns.extend">
        function <span class="apidocSignatureSpan">nlp_compromise.fns.</span>extend
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (a, b) {
  const keys = Object.keys(b);
  for(let i = 0; i &#x3c; keys.length; i++) {
    a[keys[i]] = b[keys[i]];
  }
  return a;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &#x27;eid al-fitr&#x27;: &#x27;july 25&#x27;,
    &#x27;diwali&#x27;: &#x27;october 21&#x27;,
    &#x27;ramadan&#x27;: &#x27;may 27&#x27;
  }
};
//select current year
var thisYear = new Date().getFullYear();
var holidays = fns.<span class="apidocCodeKeywordSpan">extend</span>(annual, astronomical[thisYear] || {});

module.exports = holidays;

},{&#x22;../fns&#x22;:23}],9:[function(_dereq_,module,exports){
&#x27;use strict&#x27;;

//these are common person titles used in the lexicon and sentence segmentation methods
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.fns.flatten" id="apidoc.element.nlp_compromise.fns.flatten">
        function <span class="apidocSignatureSpan">nlp_compromise.fns.</span>flatten
        <span class="apidocSignatureSpan">(arr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">flatten = function (arr) {
  let all = [];
  arr.forEach(function(a) {
    all = all.concat(a);
  });
  return all;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
const naiive_split = function(text) {
//first, split by newline
let splits = text.split(/(\n+)/);
//split by period, question-mark, and exclamation-mark
splits = splits.map(function(str) {
  return str.split(/(\S.+?[.!?])(?=\s+|$)/g);
});
return fns.<span class="apidocCodeKeywordSpan">flatten</span>(splits);
};

const sentence_parser = function(text) {
const sentences = [];
//first do a greedy-split..
let chunks = [];
//ensure it &#x27;smells like&#x27; a sentence
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.fns.isFunction" id="apidoc.element.nlp_compromise.fns.isFunction">
        function <span class="apidocSignatureSpan">nlp_compromise.fns.</span>isFunction
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isFunction = function (obj) {
  return Object.prototype.toString.call(obj) === &#x27;[object Function]&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

function NLP() {

this.plugin = function (obj) {
  obj = obj || {};
  // if obj is a function, pass it an instance of this nlp library
  if (fns.<span class="apidocCodeKeywordSpan">isFunction</span>(obj)) {
    // run it in this current context
    obj = obj.call(this, this);
  }
  //apply each plugin to the correct prototypes
  Object.keys(obj).forEach(function (k) {
    Object.keys(obj[k]).forEach(function (method) {
      models[k].prototype[method] = obj[k][method];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.fns.pluck" id="apidoc.element.nlp_compromise.fns.pluck">
        function <span class="apidocSignatureSpan">nlp_compromise.fns.</span>pluck
        <span class="apidocSignatureSpan">(arr, str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pluck = function (arr, str) {
  arr = arr || [];
  return arr.map(function(o) {
    return o[str];
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//add all names
addArr(Object.keys(firstNames.all), &#x27;Person&#x27;);
//overwrite to MalePerson, FemalePerson
addArr(firstNames.male, &#x27;MalePerson&#x27;);
addArr(firstNames.female, &#x27;FemalePerson&#x27;);
//add irregular nouns
var irregNouns = _dereq_(&#x27;./data/irregular_nouns.js&#x27;);
addArr(fns.<span class="apidocCodeKeywordSpan">pluck</span>(irregNouns, 0), &#x27;Noun&#x27;);
addArr(fns.pluck(irregNouns, 1), &#x27;Plural&#x27;);

addObj(_dereq_(&#x27;./data/misc.js&#x27;));
addObj(_dereq_(&#x27;./data/multiples.js&#x27;));
addObj(_dereq_(&#x27;./data/phrasal_verbs.js&#x27;));
//add named holidays, like &#x27;easter&#x27;
Object.keys(_dereq_(&#x27;./data/holidays.js&#x27;)).forEach(function (k) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.fns.reverseObj" id="apidoc.element.nlp_compromise.fns.reverseObj">
        function <span class="apidocSignatureSpan">nlp_compromise.fns.</span>reverseObj
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reverseObj = function (obj) {
  return Object.keys(obj).reduce(function(h, k) {
    h[obj[k]] = k;
    return h;
  }, {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x27;everybody&#x27;: &#x27;nobody&#x27;,
&#x27;someone&#x27;: &#x27;no one&#x27;,
&#x27;somebody&#x27;: &#x27;nobody&#x27;,
// everything:&#x22;nothing&#x22;,
&#x27;always&#x27;: &#x27;never&#x27;
};
//create corrollary
var logical_affirm = fns.<span class="apidocCodeKeywordSpan">reverseObj</span>(logical_negate);
//these are not symmetic
logical_affirm[&#x27;nobody&#x27;] = &#x27;somebody&#x27;;

var negate = function negate(s) {
var _loop = function _loop(i) {
  var t = s.terms[i];
  //these verbs are red-herrings
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.fns.startsWith" id="apidoc.element.nlp_compromise.fns.startsWith">
        function <span class="apidocSignatureSpan">nlp_compromise.fns.</span>startsWith
        <span class="apidocSignatureSpan">(str, prefix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">startsWith = function (str, prefix) {
  if (str &#x26;&#x26; str.length &#x26;&#x26; str.substr(0, 1) === prefix) {
    return true;
  }
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var parse_term = function parse_term(term, i) {
term = term || &#x27;&#x27;;
term = term.trim();
var signals = {};
//order matters!

//leading ^ flag
if (fns.<span class="apidocCodeKeywordSpan">startsWith</span>(term, &#x27;^&#x27;)) {
  term = term.substr(1, term.length);
  signals.leading = true;
}
//trailing $ flag means ending
if (fns.endsWith(term, &#x27;$&#x27;)) {
  term = term.replace(/\$$/, &#x27;&#x27;);
  signals.trailing = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.fns.titlecase" id="apidoc.element.nlp_compromise.fns.titlecase">
        function <span class="apidocSignatureSpan">nlp_compromise.fns.</span>titlecase
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">titlecase = function (str) {
  if (!str) {
    return &#x27;&#x27;;
  }
  str = str.toLowerCase();
  return str.charAt(0).toUpperCase() + str.slice(1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      return true;
    }
  }
  return false;
}
//support [Pos] syntax
if (signals.pos) {
  var pos = fns.<span class="apidocCodeKeywordSpan">titlecase</span>(reg.term);
  if (term.pos[pos]) {
    return true;
  }
  return false;
}
//support ~alias~ syntax
if (signals.alias) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.fns.toObj" id="apidoc.element.nlp_compromise.fns.toObj">
        function <span class="apidocSignatureSpan">nlp_compromise.fns.</span>toObj
        <span class="apidocSignatureSpan">(arr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toObj = function (arr) {
  return arr.reduce(function(h, a) {
    h[a] = true;
    return h;
  }, {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function _inherits(subClass, superClass) { if (typeof superClass !== &#x22;function&#x22; &#x26;&#x26; superClass !== null) { throw
 new TypeError(&#x22;Super expression must either be null or a function, not &#x22; + typeof superClass); } subClass.prototype =
Object.create(superClass &#x26;&#x26; superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true,
configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__
 = superClass; }

var Noun = _dereq_(&#x27;../noun.js&#x27;);
var places = _dereq_(&#x27;../../../data/places.js&#x27;);
var fns = _dereq_(&#x27;../../../fns.js&#x27;);
//make cities/countries easy to lookup
var countries = fns.<span class="apidocCodeKeywordSpan">toObj</span>(places.countries);
var cities = fns.toObj(places.cities);

var Place = function (_Noun) {
_inherits(Place, _Noun);

function Place(str, tag) {
  _classCallCheck(this, Place);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nlp_compromise.index" id="apidoc.module.nlp_compromise.index">module nlp_compromise.index</a></h1>


    <h2>
        <a href="#apidoc.element.nlp_compromise.index.adjective" id="apidoc.element.nlp_compromise.index.adjective">
        function <span class="apidocSignatureSpan">nlp_compromise.index.</span>adjective
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">adjective = function (s) {
  return new models.Adjective(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.index.adverb" id="apidoc.element.nlp_compromise.index.adverb">
        function <span class="apidocSignatureSpan">nlp_compromise.index.</span>adverb
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">adverb = function (s) {
  return new models.Adverb(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.index.date" id="apidoc.element.nlp_compromise.index.date">
        function <span class="apidocSignatureSpan">nlp_compromise.index.</span>date
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">date = function (s) {
  return new models.Date(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}(Noun);

_Date.fn = _Date.prototype;

module.exports = _Date;

// let d = new _Date(&#x27;June 4th 1993&#x27;);
// console.log(d.<span class="apidocCodeKeywordSpan">date</span>());

},{&#x22;../noun.js&#x22;:80,&#x22;./parse_date.js&#x22;:77}],75:[function(_dereq_,module,exports){
&#x27;use strict&#x27;;

var months = _dereq_(&#x27;../../../data/dates&#x27;).months.concat([&#x27;march&#x27;, &#x27;may&#x27;]); //(march and may are
ambiguous grammatically)
var month = &#x27;(&#x27; + months.join(&#x27;|&#x27;) + &#x27;)&#x27;;
var day = &#x27;([0-9]{1,2})&#x27;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.index.lexicon" id="apidoc.element.nlp_compromise.index.lexicon">
        function <span class="apidocSignatureSpan">nlp_compromise.index.</span>lexicon
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lexicon = function (obj) {
  obj = obj || {};
  let lex = require(&#x27;./lexicon.js&#x27;);

  Object.keys(obj).forEach(function(k) {
    lex[k] = obj[k];
  });

  return lex;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Uses semver, with occasional releases to npm and bower.

here, &#x27;Major&#x27; is considered an api change, while &#x27;Minor&#x27; is considered a performance change.

### v.6  &#x26;nbsp;
* 6.5.0 - builds now using browserify + derequire()
* 6.4.0 - re-written term-lumper logic
* 6.3.0 - new nlp.<span class="apidocCodeKeywordSpan">lexicon</span>({word:&#x27;POS&#x27;}) flow
* 6.0.0 - be consistent with `text.normal()`, `term.all_forms()`, `text.word_count()`. `text.normal()` includes sentence-terminators
, like periods etc.

### v.5  &#x26;nbsp;
* 5.2.0 - airport codes support, helper methods for specific POS
* 5.1.0 - newlines split sentences
* 5.0.0 - Text methods now return this, instead of array of sentences
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.index.noun" id="apidoc.element.nlp_compromise.index.noun">
        function <span class="apidocSignatureSpan">nlp_compromise.index.</span>noun
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">noun = function (s) {
  return new models.Noun(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
&#x3e; `npm install nlp_compromise`

&#x3e; `&#x3c;script src=&#x22;https://unpkg.com/nlp_compromise@latest/builds/nlp_compromise.min.js&#x22;&#x3e;&#x3c;/script&#x3e
;`

```javascript
let nlp = require(&#x27;nlp_compromise&#x27;); // or nlp = window.nlp_compromise

nlp.<span class="apidocCodeKeywordSpan">noun</span>(&#x27;dinosaur&#x27;).pluralize();
// &#x27;dinosaurs&#x27;

nlp.verb(&#x27;speak&#x27;).conjugate();
// { past: &#x27;spoke&#x27;,
//   infinitive: &#x27;speak&#x27;,
//   gerund: &#x27;speaking&#x27;,
//   actor: &#x27;speaker&#x27;,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.index.organization" id="apidoc.element.nlp_compromise.index.organization">
        function <span class="apidocSignatureSpan">nlp_compromise.index.</span>organization
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">organization = function (s) {
  return new models.Organization(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.index.person" id="apidoc.element.nlp_compromise.index.person">
        function <span class="apidocSignatureSpan">nlp_compromise.index.</span>person
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">person = function (s) {
  return new models.Person(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

nlp.text(&#x27;Tony Hawk did a kickflip&#x27;).people();
// [ Person { text: &#x27;Tony Hawk&#x27; ..} ]

nlp.noun(&#x27;vacuum&#x27;).article();
// &#x27;a&#x27;

nlp.<span class="apidocCodeKeywordSpan">person</span>(&#x27;Tony Hawk&#x27;).pronoun();
// &#x27;he&#x27;

nlp.value(&#x27;five hundred and sixty&#x27;).number;
// 560

nlp.text(require(&#x27;nlp-corpus&#x27;).text.friends()).topics()//11 seasons of friends
// [ { count: 2523, text: &#x27;ross&#x27; },
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.index.place" id="apidoc.element.nlp_compromise.index.place">
        function <span class="apidocSignatureSpan">nlp_compromise.index.</span>place
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">place = function (s) {
  return new models.Place(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### v.2
* v2.0.0 - Nov 2015 &#x26;nbsp;  **(Breaking)**
* es6 classes, babel building
* better test coverage
* ngram uses term tokenization, so that &#x27;Tony Hawk&#x27; us one term, and not two
* more organized pos rules
* Pos tagging is done implicitly now once nlp.Text is run
* Entity spotting is split into .people(), .<span class="apidocCodeKeywordSpan">place</span>(), .organisations()
* unicode normalisation is killed
* opaque two-letter tags are gone
* plugin support
* passive tense detection
* lexicon can be augmented third-party
* date parsing results are different
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.index.plugin" id="apidoc.element.nlp_compromise.index.plugin">
        function <span class="apidocSignatureSpan">nlp_compromise.index.</span>plugin
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">plugin = function (obj) {
  obj = obj || {};
  // if obj is a function, pass it an instance of this nlp library
  if (fns.isFunction(obj)) {
    // run it in this current context
    obj = obj.call(this, this);
  }
  //apply each plugin to the correct prototypes
  Object.keys(obj).forEach(function(k) {
    Object.keys(obj[k]).forEach(function(method) {
      models[k].prototype[method] = obj[k][method];
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//   { count: 1411, text: &#x27;rachel&#x27; },
//   ....
```
#Plugin/Mixins
we&#x27;ve also got a modest, though ambitious [plugin ecosystem](https://github.com/nlp-compromise/nlp_compromise/wiki/Plugins):
```javascript
//US-UK localization
nlp.<span class="apidocCodeKeywordSpan">plugin</span>(require(&#x27;nlp-locale&#x27;))
nlp.term(&#x27;favourite&#x27;).toAmerican()
// &#x27;favorite&#x27;

//syllable hyphenization
nlp.plugin(require(&#x27;nlp-syllables&#x27;));
var t2 = nlp.term(&#x27;houston texas&#x27;);
t2.syllables()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.index.question" id="apidoc.element.nlp_compromise.index.question">
        function <span class="apidocSignatureSpan">nlp_compromise.index.</span>question
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">question = function (s) {
  return new models.Question(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.index.sentence" id="apidoc.element.nlp_compromise.index.sentence">
        function <span class="apidocSignatureSpan">nlp_compromise.index.</span>sentence
        <span class="apidocSignatureSpan">(s, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sentence = function (s, options) {
  return new models.Sentence(s, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

[![CodacyBadge](https://api.codacy.com/project/badge/grade/82cc8ebd98b64ed199d7be6021488062)](https://www.codacy.com/app/spencerkelly86
/nlp_compromise)
[![npm version](https://badge.fury.io/js/nlp_compromise.svg)](https://www.npmjs.com/package/nlp_compromise)
[![downloads](https://img.shields.io/npm/dm/nlp_compromise.svg)](https://www.npmjs.com/package/nlp_compromise)

**nlp_compromise** does NLP in the browser.
```javascript
nlp.<span class="apidocCodeKeywordSpan">sentence</span>(&#x27;She sells seashells&#x27;).to_past().text()
// &#x27;She sold seashells&#x27;
```
### Yup,
* **&#x3c;150k** js file
* **86%** on the [Penn treebank](http://www.cis.upenn.edu/~treebank/)
* keypress speed, constant-time.
* caniuse, uhuh. **IE9+**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.index.statement" id="apidoc.element.nlp_compromise.index.statement">
        function <span class="apidocSignatureSpan">nlp_compromise.index.</span>statement
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">statement = function (s) {
  return new models.Statement(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//   present: &#x27;speaks&#x27;,
//   future: &#x27;will speak&#x27;,
//   perfect: &#x27;have spoken&#x27;,
//   pluperfect: &#x27;had spoken&#x27;,
//   future_perfect: &#x27;will have spoken&#x27;
// }

nlp.<span class="apidocCodeKeywordSpan">statement</span>(&#x27;She sells seashells&#x27;).negate().text()
// &#x27;She doesn&#x27;t sell seashells&#x27;

nlp.sentence(&#x27;I fed the dog&#x27;).replace(&#x27;the [Noun]&#x27;, &#x27;the cat&#x27;).text()
// &#x27;I fed the cat&#x27;

nlp.text(&#x27;Tony Hawk did a kickflip&#x27;).people();
// [ Person { text: &#x27;Tony Hawk&#x27; ..} ]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.index.term" id="apidoc.element.nlp_compromise.index.term">
        function <span class="apidocSignatureSpan">nlp_compromise.index.</span>term
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">term = function (s) {
  return new models.Term(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//   ....
```
#Plugin/Mixins
we&#x27;ve also got a modest, though ambitious [plugin ecosystem](https://github.com/nlp-compromise/nlp_compromise/wiki/Plugins):
```javascript
//US-UK localization
nlp.plugin(require(&#x27;nlp-locale&#x27;))
nlp.<span class="apidocCodeKeywordSpan">term</span>(&#x27;favourite&#x27;).toAmerican()
// &#x27;favorite&#x27;

//syllable hyphenization
nlp.plugin(require(&#x27;nlp-syllables&#x27;));
var t2 = nlp.term(&#x27;houston texas&#x27;);
t2.syllables()
//[ [ &#x27;hous&#x27;, &#x27;ton&#x27; ], [ &#x27;tex&#x27;, &#x27;as&#x27; ] ]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.index.text" id="apidoc.element.nlp_compromise.index.text">
        function <span class="apidocSignatureSpan">nlp_compromise.index.</span>text
        <span class="apidocSignatureSpan">(s, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">text = function (s, options) {
  return new models.Text(s, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### v.4  &#x26;nbsp;
* 4.12.0 - more-sensible responses for invalid, non-string inputs
* 4.11.0 - 14 PRs, with fixes for currencies, pluralization, conjugation
* 4.10.0 - Value.to_text() new method, fix &#x22;Posessive&#x22; POS typo
* 4.9.0 - return of the text.spot() method (Re:#107)
* 4.8.0 - more aggressive lumping of dates, like &#x27;last week of february&#x27;
* 4.7.0 - whitespace reproduction in .<span class="apidocCodeKeywordSpan">text</span>() methods
* 4.6.0 - move negate from sentence to verb &#x26; statement
* 4.2.0 - rename &#x27;implicit&#x27; to &#x27;expansion&#x27; for smarter contractions
* 4.1.3 - added readable-compression to adj, verbs (121kb -&#x3e; 117kb)
* 4.1.0 - hyphenated words are normalized into spaces
* 4.0.0 - grammar-aware match &#x26; replace functions

### v.3  &#x26;nbsp;  **(Breaking)**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.index.value" id="apidoc.element.nlp_compromise.index.value">
        function <span class="apidocSignatureSpan">nlp_compromise.index.</span>value
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">value = function (s) {
  return new models.Value(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

nlp.noun(&#x27;vacuum&#x27;).article();
// &#x27;a&#x27;

nlp.person(&#x27;Tony Hawk&#x27;).pronoun();
// &#x27;he&#x27;

nlp.<span class="apidocCodeKeywordSpan">value</span>(&#x27;five hundred and sixty&#x27;).number;
// 560

nlp.text(require(&#x27;nlp-corpus&#x27;).text.friends()).topics()//11 seasons of friends
// [ { count: 2523, text: &#x27;ross&#x27; },
//   { count: 1922, text: &#x27;joey&#x27; },
//   { count: 1876, text: &#x27;god&#x27; },
//   { count: 1411, text: &#x27;rachel&#x27; },
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.index.verb" id="apidoc.element.nlp_compromise.index.verb">
        function <span class="apidocSignatureSpan">nlp_compromise.index.</span>verb
        <span class="apidocSignatureSpan">(s)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">verb = function (s) {
  return new models.Verb(s);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
let nlp = require(&#x27;nlp_compromise&#x27;); // or nlp = window.nlp_compromise

nlp.noun(&#x27;dinosaur&#x27;).pluralize();
// &#x27;dinosaurs&#x27;

nlp.<span class="apidocCodeKeywordSpan">verb</span>(&#x27;speak&#x27;).conjugate();
// { past: &#x27;spoke&#x27;,
//   infinitive: &#x27;speak&#x27;,
//   gerund: &#x27;speaking&#x27;,
//   actor: &#x27;speaker&#x27;,
//   present: &#x27;speaks&#x27;,
//   future: &#x27;will speak&#x27;,
//   perfect: &#x27;have spoken&#x27;,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nlp_compromise.match" id="apidoc.module.nlp_compromise.match">module nlp_compromise.match</a></h1>


    <h2>
        <a href="#apidoc.element.nlp_compromise.match.findAll" id="apidoc.element.nlp_compromise.match.findAll">
        function <span class="apidocSignatureSpan">nlp_compromise.match.</span>findAll
        <span class="apidocSignatureSpan">(terms, regs, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findAll = function (terms, regs, options) {
  let result = [];
  regs = syntax_parse(regs || &#x27;&#x27;);
  // one-off lookup for ^
  // &#x27;^&#x27; token is &#x27;must start at 0&#x27;
  if (regs[0].signals.leading) {
    let match = tryFromHere(terms, regs, options) || [];
    if (match) {
      return [new Result(match)];
    } else {
      return null;
    }
  }

  //repeating version starting from each term
  let len = terms.length; // - regs.length + 1;
  for(let i = 0; i &#x3c; len; i++) {
    let termSlice = terms.slice(i, terms.length);
    let match = tryFromHere(termSlice, regs, options);
    if (match) {
      result.push(new Result(match));
    }
  }
  //if we have no results, return null
  if (result.length === 0) {
    return null;
  }
  return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // a regex-like lookup for a list of terms.
  // returns [] of matches in a &#x27;Terms&#x27; class

}, {
  key: &#x27;match&#x27;,
  value: function match(match_str, options) {
    var regs = tokenize_match(match_str);
    return _match.<span class="apidocCodeKeywordSpan">findAll</span>(this.terms, regs, options);
  }
  //returns a transformed sentence

}, {
  key: &#x27;replace&#x27;,
  value: function replace(match_str, replacement, options) {
    var regs = tokenize_match(match_str);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.match.replaceAll" id="apidoc.element.nlp_compromise.match.replaceAll">
        function <span class="apidocSignatureSpan">nlp_compromise.match.</span>replaceAll
        <span class="apidocSignatureSpan">(terms, regs, replacement, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replaceAll = function (terms, regs, replacement, options) {
  let list = findAll(terms, regs, options);
  if (list) {
    list.forEach((t) =&#x3e; {
      t.replace(replacement, options);
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  //returns a transformed sentence

}, {
  key: &#x27;replace&#x27;,
  value: function replace(match_str, replacement, options) {
    var regs = tokenize_match(match_str);
    replacement = tokenize_match(replacement);
    _match.<span class="apidocCodeKeywordSpan">replaceAll</span>(this.terms, regs, replacement, options);
    return this;
  }

  //the ending punctuation

}, {
  key: &#x27;terminator&#x27;,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nlp_compromise.parts_of_speech" id="apidoc.module.nlp_compromise.parts_of_speech">module nlp_compromise.parts_of_speech</a></h1>


    <h2>
        <a href="#apidoc.element.nlp_compromise.parts_of_speech.Adjective" id="apidoc.element.nlp_compromise.parts_of_speech.Adjective">
        function <span class="apidocSignatureSpan">nlp_compromise.parts_of_speech.</span>Adjective
        <span class="apidocSignatureSpan">(str, tag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Adjective extends Term {
  constructor(str, tag) {
    super(str);
    this.tag = tag;
    if (tag) {
      this.pos[tag] = true;
    }
    this.pos[&#x27;Adjective&#x27;] = true;
  }

  to_comparative() {
    return to_comparative(this.normal);
  }
  to_superlative() {
    return to_superlative(this.normal);
  }
  to_noun() {
    return adj_to_noun(this.normal);
  }
  to_adverb() {
    return adj_to_adv(this.normal);
  }
  conjugate() {
    return {
      comparative: to_comparative(this.normal),
      superlative: to_superlative(this.normal),
      adverb: adj_to_adv(this.normal),
      noun: adj_to_noun(this.normal)
    };
  }
  all_forms() {
    let forms = this.conjugate();
    forms[&#x27;normal&#x27;] = this.normal;
    return forms;
  }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.noun = function (s) {
  return new models.Noun(s);
};
this.verb = function (s) {
  return new models.Verb(s);
};
this.adjective = function (s) {
  return new models.<span class="apidocCodeKeywordSpan">Adjective</span>(s);
};
this.adverb = function (s) {
  return new models.Adverb(s);
};

this.value = function (s) {
  return new models.Value(s);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.parts_of_speech.Adverb" id="apidoc.element.nlp_compromise.parts_of_speech.Adverb">
        function <span class="apidocSignatureSpan">nlp_compromise.parts_of_speech.</span>Adverb
        <span class="apidocSignatureSpan">(str, tag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Adverb extends Term {
  constructor(str, tag) {
    super(str);
    this.tag = tag;
    this.pos[&#x27;Adverb&#x27;] = true;
  }
  to_adjective() {
    return to_adjective(this.normal);
  }
  all_forms() {
    return {
      adjective: this.to_adjective(),
      normal: this.normal
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.verb = function (s) {
  return new models.Verb(s);
};
this.adjective = function (s) {
  return new models.Adjective(s);
};
this.adverb = function (s) {
  return new models.<span class="apidocCodeKeywordSpan">Adverb</span>(s);
};

this.value = function (s) {
  return new models.Value(s);
};
this.person = function (s) {
  return new models.Person(s);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.parts_of_speech.Date" id="apidoc.element.nlp_compromise.parts_of_speech.Date">
        function <span class="apidocSignatureSpan">nlp_compromise.parts_of_speech.</span>Date
        <span class="apidocSignatureSpan">(str, tag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class _Date extends Noun {
  constructor(str, tag) {
    super(str);
    this.tag = tag;
    this.pos[&#x27;Date&#x27;] = true;
    this.data = parse_date(this.text) || {};
  }

  //can we make it a js Date object?
  is_date() {
    let o = this.data;
    if (o.month === null || o.day === null || o.year === null) {
      return false;
    }
    return true;
  }

  date() {
    if (this.is_date() === false) {
      return null;
    }
    let d = new Date();
    if (this.data.year) {
      d.setYear(this.data.year);
    }
    if (this.data.month !== null) {
      d.setMonth(this.data.month);
    }
    if (this.data.day !== null) {
      d.setDate(this.data.day);
    }
    return d;
  }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.person = function (s) {
  return new models.Person(s);
};
this.place = function (s) {
  return new models.Place(s);
};
this.date = function (s) {
  return new models.<span class="apidocCodeKeywordSpan">Date</span>(s);
};
this.organization = function (s) {
  return new models.Organization(s);
};

this.text = function (s, options) {
  return new models.Text(s, options);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.parts_of_speech.Noun" id="apidoc.element.nlp_compromise.parts_of_speech.Noun">
        function <span class="apidocSignatureSpan">nlp_compromise.parts_of_speech.</span>Noun
        <span class="apidocSignatureSpan">(str, tag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Noun extends Term {
  constructor(str, tag) {
    super(str);
    this.tag = tag;
    this.pos[&#x27;Noun&#x27;] = true;
    if (tag) {
      this.pos[tag] = true;
    }
    if (this.is_plural()) {
      this.pos[&#x27;Plural&#x27;] = true;
    }
  }
  //noun methods
  article() {
    //if it&#x27;s a person, it&#x27;s he/she, not a/an
    if (this.pos[&#x27;Person&#x27;]) {
      return this.pronoun();
    }
    //groups of people are &#x27;they&#x27;
    if (this.pos[&#x27;Organization&#x27;]) {
      return &#x27;they&#x27;;
    }
    return article(this.text);
  }
  root() {
    return this.singularize();
  }
  pronoun() {
    if (this.is_organization() || this.is_place() || this.is_value()) {
      return &#x27;it&#x27;;
    }
    return pronoun(this.normal);
  }
  is_plural() {
    if (this.pos[&#x27;Date&#x27;] || this.pos[&#x27;Possessive&#x27;]) {
      return false;
    } else if (this.has_abbreviation()) { //contractions &#x26; possessives are not plural
      return false;
    } else {
      return is_plural(this.normal);
    }
  }
  is_uncountable() {
    return is_uncountable(this.strip_apostrophe());
  }
  pluralize() {
    return pluralize(this.strip_apostrophe());
  }
  singularize() {
    return singularize(this.strip_apostrophe());
  }
  //sub-classes
  is_person() {
    //don&#x27;t overwrite dates, etc
    if (this.pos[&#x27;Date&#x27;]) {
      return false;
    }
    return is_person(this.strip_apostrophe());
  }
  is_organization() {
    //don&#x27;t overwrite urls
    if (this.pos[&#x27;Url&#x27;]) {
      return false;
    }
    return is_organization(this.strip_apostrophe(), this.text);
  }
  is_date() {
    return is_date(this.strip_apostrophe());
  }
  is_value() {
    //don&#x27;t overwrite dates, etc
    if (this.pos[&#x27;Date&#x27;] || this.pos[&#x27;HashTag&#x27;]) {
      return false;
    }
    return is_value(this.strip_apostrophe());
  }
  is_place() {
    return is_place(this.strip_apostrophe());
  }
  all_forms() {
    return {
      &#x27;singular&#x27;: this.singularize(),
      &#x27;plural&#x27;: this.pluralize(),
      &#x27;normal&#x27;: this.normal
    };
  }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return lex;
};

this.term = function (s) {
  return new models.Term(s);
};
this.noun = function (s) {
  return new models.<span class="apidocCodeKeywordSpan">Noun</span>(s);
};
this.verb = function (s) {
  return new models.Verb(s);
};
this.adjective = function (s) {
  return new models.Adjective(s);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.parts_of_speech.Organization" id="apidoc.element.nlp_compromise.parts_of_speech.Organization">
        function <span class="apidocSignatureSpan">nlp_compromise.parts_of_speech.</span>Organization
        <span class="apidocSignatureSpan">(str, tag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Organization extends Noun {
  constructor(str, tag) {
    super(str);
    this.tag = tag;
    this.pos[&#x27;Organization&#x27;] = true;

  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.place = function (s) {
  return new models.Place(s);
};
this.date = function (s) {
  return new models.Date(s);
};
this.organization = function (s) {
  return new models.<span class="apidocCodeKeywordSpan">Organization</span>(s);
};

this.text = function (s, options) {
  return new models.Text(s, options);
};
this.sentence = function (s, options) {
  return new models.Sentence(s, options);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.parts_of_speech.Person" id="apidoc.element.nlp_compromise.parts_of_speech.Person">
        function <span class="apidocSignatureSpan">nlp_compromise.parts_of_speech.</span>Person
        <span class="apidocSignatureSpan">(str, tag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Person extends Noun {
  constructor(str, tag) {
    super(str);
    this.tag = tag;
    this.pos[&#x27;Person&#x27;] = true;
    this.honourific = null;
    this.firstName = null;
    this.middleName = null;
    this.lastName = null;
    this.parse();
    if (this.isPronoun()) {
      this.pos[&#x27;Pronoun&#x27;] = true;
    }
    if (tag) {
      this.pos[tag] = true;
    }
  }

  isPronoun() {
    let whitelist = {
      &#x27;he&#x27;: true,
      &#x27;she&#x27;: true,
      &#x27;i&#x27;: true,
      &#x27;you&#x27;: true,
    };
    return whitelist[this.normal];
  }

  //proper normalised name without the cruft
  root() {
    if (this.isPronoun()) {
      return this.normal;
    }
    let str = &#x27;&#x27;;

    if (this.firstName) {
      str = this.firstName.toLowerCase();
    }
    if (this.middleName) {
      str += &#x27; &#x27; + this.middleName.toLowerCase();
    }
    if (this.lastName) {
      str += &#x27; &#x27; + this.lastName.toLowerCase();
    }
    return str.trim() || this.normal;
  }

  //turn a multi-word string into [first, middle, last, honourific]
  parse() {
    let o = parse_name(this.normal, this.text.trim());
    this.honourific = o.honourific;
    this.firstName = title_case(o.firstName);
    this.middleName = title_case(o.middleName);
    this.lastName = lastname_case(o.lastName);
  }

  gender() {
    //if we already know it, from the lexicon
    if (this.pos.FemalePerson) {
      return &#x27;Female&#x27;;
    }
    if (this.pos.MalePerson) {
      return &#x27;Male&#x27;;
    }
    return guess_gender(this.normal);
  }

  pronoun() {
    const pronouns = {
      Male: &#x27;he&#x27;,
      Female: &#x27;she&#x27;,
    };
    let gender = this.gender();
    //return &#x27;singular they&#x27; if no gender is found
    return pronouns[gender] || &#x27;they&#x27;;
  }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return new models.Adverb(s);
};

this.value = function (s) {
  return new models.Value(s);
};
this.person = function (s) {
  return new models.<span class="apidocCodeKeywordSpan">Person</span>(s);
};
this.place = function (s) {
  return new models.Place(s);
};
this.date = function (s) {
  return new models.Date(s);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.parts_of_speech.Place" id="apidoc.element.nlp_compromise.parts_of_speech.Place">
        function <span class="apidocSignatureSpan">nlp_compromise.parts_of_speech.</span>Place
        <span class="apidocSignatureSpan">(str, tag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Place extends Noun {
  constructor(str, tag) {
    super(str);
    this.tag = tag;
    this.pos[&#x27;Place&#x27;] = true;
    this.pos[tag] = true;
    this.title = null;
    this.city = null;
    this.region = null; //&#x27;2nd-tier&#x27; (state/province/county/whatever)
    this.country = null;
    this.parse();
  }
  root() {
    return this.title || this.normal;
  }

  parse() {
    //parse a comma-described place like &#x22;toronto, ontario&#x22;
    let terms = this.strip_apostrophe().split(&#x27; &#x27;);
    this.title = terms[0];
    for(let i = 1; i &#x3c; terms.length; i++) {
      let t = terms[i];
      if (cities[t]) {
        this.city = fns.titlecase(t);
      } else if (countries[t]) {
        this.country = fns.titlecase(t);
      } else if (this.city !== null) { //if we already got the city..
        this.region = fns.titlecase(t);
      } else { //it&#x27;s part of the title
        this.title += &#x27; &#x27; + t;
      }
    }

  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.value = function (s) {
  return new models.Value(s);
};
this.person = function (s) {
  return new models.Person(s);
};
this.place = function (s) {
  return new models.<span class="apidocCodeKeywordSpan">Place</span>(s);
};
this.date = function (s) {
  return new models.Date(s);
};
this.organization = function (s) {
  return new models.Organization(s);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.parts_of_speech.Term" id="apidoc.element.nlp_compromise.parts_of_speech.Term">
        function <span class="apidocSignatureSpan">nlp_compromise.parts_of_speech.</span>Term
        <span class="apidocSignatureSpan">(str, tag, whitespace)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Term {
  constructor(str, tag, whitespace) {
    //don&#x27;t pass non-strings through here any further..
    if (typeof str === &#x27;number&#x27;) {
      str = &#x27;&#x27; + str;
    } else if (typeof str !== &#x27;string&#x27;) {
      str = &#x27;&#x27;;
    }
    str = (str).toString();
    //trailing &#x26; preceding whitespace
    this.whitespace = whitespace || {};
    this.whitespace.preceding = this.whitespace.preceding || &#x27;&#x27;;
    this.whitespace.trailing = this.whitespace.trailing || &#x27;&#x27;;
    //set .text
    this.text = str;
    //the normalised working-version of the word
    this.normal = &#x27;&#x27;;
    //if it&#x27;s a contraction or slang, the implication, or &#x27;hidden word&#x27;
    this.expansion = &#x27;&#x27;;
    //set .normal
    this.rebuild();
    //the reasoning behind it&#x27;s part-of-speech
    this.reasoning = [];
    //these are orphaned POS that have no methods
    this.pos = {};
    this.tag = tag || &#x27;?&#x27;;
    if (tag) {
      this.pos[tag] = true;
    }
  }

  //when the text changes, rebuild derivative fields
  rebuild() {
    this.text = this.text || &#x27;&#x27;;
    this.text = this.text.trim();

    this.normal = &#x27;&#x27;;
    this.normalize();
    this.expansion = implied(this.normal);
  }
  changeTo(str) {
    this.text = str;
    this.rebuild();
  }
  //a regex-like string search
  match(match_str, options) {
    let reg = syntax_parse([match_str]);
    return match_term(this, reg[0], options);
  }
  //the &#x27;root&#x27; singular/infinitive/whatever.
  // method is overloaded by each pos type
  root() {
    return this.strip_apostrophe();
  }
  //strip apostrophe s
  strip_apostrophe() {
    if (this.normal.match(/[a-z]&#x27;[a-z][a-z]?$/)) {
      let split = this.normal.split(/&#x27;/);
      if (split[1] === &#x27;s&#x27;) {
        return split[0];
      }
    }
    return this.normal;
  }

  has_comma() {
    if (this.text.match(/,$/)) {
      return true;
    }
    return false;
  }
  has_abbreviation() {
    // &#x22;spencer&#x27;s&#x22;
    if (this.text.match(/[a-z]&#x27;[a-z][a-z]?$/)) {
      return true;
    }
    // &#x22;flanders&#x27; house&#x22;
    if (this.text.match(/[a-z]s&#x27;$/)) {
      return true;
    }
    return false;
  }

  is_capital() {
    if (this.text.match(/[A-Z][a-z]/)) {
      return true;
    }
    return false;
  }
  //utility method to avoid lumping words with non-word stuff
  is_word() {
    if (this.text.match(/^\[.*?\]\??$/)) {
      return false;
    }
    if (!this.text.match(/[a-z|0-9]/i)) {
      return false;
    }
    if (this.text.match(/[\|#\&#x3c;\&#x3e;]/i)) {
      return false;
    }
    return true;
  }
  //FBI or F.B.I.
  is_acronym() {
    return is_acronym(this.text);
  }
  //working word
  normalize() {
    let str = this.text || &#x27;&#x27;;
    str = str.toLowerCase();
    //strip grammatical punctuation
    str = str.replace(/[,\.!:;\?\(\)^$]/g, &#x27;&#x27;);
    //hashtags, atmentions
    str = str.replace(/^[#@]/, &#x27;&#x27;);
    //convert hyphenations to a multiple-word term
    str = str.replace(/([a-z])\-([a-z])/g, &#x27;$1 $2&#x27;);
    // coerce single curly quotes
    str = str.replace(/[\u2018\u2019\u201A\u201B\u2032\u2035]+/g, &#x27;\&#x27;&#x27;);
    // coerce double curly quotes
    str = str.replace(/[\u201C\u201D\u201E\u201F\u2033\u2036]+/g, &#x27;&#x27;);
    //remove quotations + scare-quotes
    str = str.replace(/^&#x27;/g, &#x27;&#x27;);
    str = str.replace(/&#x27;$/g, &#x27;&#x27;);
    str = str.replace(/&#x22;/g, &#x27;&#x27;);
    if (!str.match(/[a-z0-9]/i)) {
      return &#x27;&#x27;;
    }
    this.normal = str;
    return this.normal;
  }

  all_forms() {
    return {};
  }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    lex[k] = obj[k];
  });

  return lex;
};

this.term = function (s) {
  return new models.<span class="apidocCodeKeywordSpan">Term</span>(s);
};
this.noun = function (s) {
  return new models.Noun(s);
};
this.verb = function (s) {
  return new models.Verb(s);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.parts_of_speech.Value" id="apidoc.element.nlp_compromise.parts_of_speech.Value">
        function <span class="apidocSignatureSpan">nlp_compromise.parts_of_speech.</span>Value
        <span class="apidocSignatureSpan">(str, tag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Value extends Noun {
  constructor(str, tag) {
    super(str);
    this.tag = tag;
    this.pos[&#x27;Value&#x27;] = true;
    this.number = null;
    this.unit = null;
    this.unit_name = null;
    this.measurement = null;
    this.of_what = &#x27;&#x27;;
    // this.text = str;
    // this.normal = str;
    if (this.is_ordinal()) {
      this.pos[&#x27;Ordinal&#x27;] = true;
    }
    this.parse();
  }

  //test for nearly-numbers, like phonenumbers, or whatever
  is_number(s) {
    //phone numbers, etc
    if (s.match(/[:@]/)) {
      return false;
    }
    //if there&#x27;s a number, then something, then a number
    if (s.match(/[0-9][^(0-9|\/),\.][0-9]/)) {
      if (s.match(/((?:[0-9]|\.)+) ((?:[0-9]|\.)+)\/((?:[0-9]|\.)+)/)) { // I&#x27;m sure there is a better regexpxs
        return true;
      }
      return false;
    }
    return true;
  };

  is_number_word(w) {
    let number_words = {
      minus: true,
      negative: true,
      point: true,
      half: true,
      quarter: true,
    };

    if (w.match(/[0-9]/) || number_words[w]) {
      return true;
    } else if (nums.ones[w] || nums.teens[w] || nums.tens[w] || nums.multiples[w]) {
      return true;
    } else if (nums.ordinal_ones[w] || nums.ordinal_teens[w] || nums.ordinal_tens[w] || nums.ordinal_multiples[w]) {
      return true;
    }

    return false;
  };


  is_ordinal() {
    //1st
    if (this.normal.match(/^[0-9]+(rd|st|nd|th)$/)) {
      return true;
    }
    //first, second...
    for(let i = 0; i &#x3c; ordinals.length; i++) {
      if (fns.endsWith(this.normal, ordinals[i])) {
        return true;
      }
    }
    return false;
  }

  //turn an integer like 22 into &#x27;22nd&#x27;
  to_ordinal() {
    let num = this.number;
    //fail fast
    if (!num &#x26;&#x26; num !== 0) {
      return &#x27;&#x27;;
    }
    //teens are all &#x27;th&#x27;
    if (num &#x3e;= 10 &#x26;&#x26; num &#x3c;= 20) {
      return &#x27;&#x27; + num + &#x27;th&#x27;;
    }
    //treat it as a string..
    num = &#x27;&#x27; + num;
    //fail safely
    if (!num.match(/[0-9]$/)) {
      return num;
    }
    if (fns.endsWith(num, &#x27;1&#x27;)) {
      return num + &#x27;st&#x27;;
    }
    if (fns.endsWith(num, &#x27;2&#x27;)) {
      return num + &#x27;nd&#x27;;
    }
    if (fns.endsWith(num, &#x27;3&#x27;)) {
      return num + &#x27;rd&#x27;;
    }
    return num + &#x27;th&#x27;;
  }

  //overwrite term.normal?
  // normal() {
  //   let str = &#x27;&#x27; + (this.number || &#x27;&#x27;);
  //   if (this.is_ordinal()) {
  //     str = this.to_ordinal(str);
  //   }
  //   if (this.unit) {
  //     str += &#x27; &#x27; + this.unit;
  //   }
  //   return str;
  // }

  root() {
    let str = this.number;
    if (this.unit) {
      str += &#x27; &#x27; + this.unit;
    }
    return str;
  }

  is_unit() {
    //if it&#x27;s a known unit
    if (units[this.unit]) {
      return true;
    }
    //currencies are derived-through POS
    if (this.pos[&#x27;Currency&#x27;]) {
      return true;
    }

    let s = this.unit.toLowerCase();
    if (nums.prefixes[s]) {
      return true;
    }

    //try singular version
    s = this.unit.replace(/s$/, &#x27;&#x27;);
    if (units[s]) {
      this.unit = this.unit.replace(/s$/, &#x27;&#x27;);
      return true;
    }

    s = this.unit.replace(/es$/, &#x27;&#x27;);
    if (units[s]) {
      this.unit = this.unit.replace(/es$/, &#x27;&#x27;);
      return true;
    }
    return false;
  }

  parse() {
    if (!this.is_number(this.text)) {
      return;
    }

    let words = this.text.toLowerCase().split(/[ ]/);
    //split at &#x27;-&#x27; only for numbers like twenty-two, sixty-seven, etc.
    //so that &#x27;twelve six-gram pieces&#x27; returns 12 for number, not null
    //however, still returns null for &#x27;three sevel-eleven stores&#x27;
    for (let i = 0; i &#x3c; words.length; i++) {
      let w = words[i];
      if ((w.indexOf(&#x27;-&#x27;) === w.lastIndexOf(&#x27;-&#x27;)) &#x26;&#x26; w.indexOf(&#x27;-&#x27;) &#x3e; -1) {
        let halves = w.split(/[-]/);
        if (this.is_number_word(halves[0]) &#x26;&#x26; this.is_number_word(halves[1])) {
          words[i] = halves[0];
          words.splice(i + 1, 0, halves[1]);
        }
      }
    }

    let numbers = &#x27;&#x27;;
    let raw_units = &#x27;&#x27;;

    //seperate number-words from unit-words
    for (let i = 0; i &#x3c; words.length; i++) {
      let w = words[i];
      if (this.is_number_word(w)) {
        numbers += &#x27; &#x27; + w; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return new models.Adjective(s);
};
this.adverb = function (s) {
  return new models.Adverb(s);
};

this.value = function (s) {
  return new models.<span class="apidocCodeKeywordSpan">Value</span>(s);
};
this.person = function (s) {
  return new models.Person(s);
};
this.place = function (s) {
  return new models.Place(s);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nlp_compromise.parts_of_speech.Verb" id="apidoc.element.nlp_compromise.parts_of_speech.Verb">
        function <span class="apidocSignatureSpan">nlp_compromise.parts_of_speech.</span>Verb
        <span class="apidocSignatureSpan">(str, tag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Verb extends Term {
  constructor(str, tag) {
    super(str);
    this.tag = tag;
    this.pos[&#x27;Verb&#x27;] = true;
    //if we&#x27;ve been told which
    if (tag) {
      this.pos[tag] = true;
    }
  }

  //&#x27;root&#x27; for a verb means infinitive
  root() {
    return this.conjugate().infinitive;
  }

  //retrieve a specific form
  conjugation() {
    //check cached conjugations
    let conjugations = this.conjugate();
    let keys = Object.keys(conjugations);
    for(let i = 0; i &#x3c; keys.length; i++) {
      if (conjugations[keys[i]] === this.normal) {
        return verbTags[keys[i]];
      }
    }
    //try to guess
    return verbTags[predict_form(this.normal)];
  }
  tense() {
    //map conjugation onto past/present/future
    let tenses = {
      infinitive: &#x27;present&#x27;,
      gerund: &#x27;present&#x27;,
      actor: &#x27;present&#x27;,
      present: &#x27;present&#x27;,
      past: &#x27;past&#x27;,
      future: &#x27;future&#x27;,
      perfect: &#x27;past&#x27;,
      pluperfect: &#x27;past&#x27;,
      future_perfect: &#x27;future&#x27;
    };
    let c = this.conjugation();
    return tenses[c] || &#x27;present&#x27;;
  }

  conjugate() {
    return conjugate(this.normal);
  }
  to_past() {
    let tense = &#x27;past&#x27;;
    let conjugations = this.conjugate(this.normal);
    this.tag = verbTags[tense];
    this.changeTo(conjugations[tense]);
    return conjugations[tense];
  }
  to_present() {
    let tense = &#x27;present&#x27;;
    let conjugations = this.conjugate(this.normal);
    this.tag = verbTags[tense];
    this.changeTo(conjugations[tense]);
    return conjugations[tense];
  }
  to_future() {
    let tense = &#x27;future&#x27;;
    let conjugations = this.conjugate(this.normal);
    this.tag = verbTags[tense];
    this.changeTo(conjugations[tense]);
    return conjugations[tense];
  }
  to_adjective() {
    return to_adjective(this.conjugate().infinitive);
  }

  //is this verb negative already?
  isNegative() {
    const str = this.normal;
    //yep, pretty simple
    if (str.match(/(n&#x27;t|\bnot\b)/)) {
      return true;
    }
    return false;
  }

  //turn &#x27;walked&#x27; to &#x22;didn&#x27;t walk&#x22;
  negate() {
    this.changeTo(negate(this));
    return this;
  }

  all_forms() {
    let forms = this.conjugate();
    forms[&#x27;negated&#x27;] = negate(this);
    forms[&#x27;normal&#x27;] = this.normal;
    return forms;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.term = function (s) {
  return new models.Term(s);
};
this.noun = function (s) {
  return new models.Noun(s);
};
this.verb = function (s) {
  return new models.<span class="apidocCodeKeywordSpan">Verb</span>(s);
};
this.adjective = function (s) {
  return new models.Adjective(s);
};
this.adverb = function (s) {
  return new models.Adverb(s);
};
...</pre></li>
    </ul>






</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
